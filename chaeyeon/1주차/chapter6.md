# 6. 데이터 타입

-   자바스크립트의 모든 값은 데이터 타입을 갖는다.
-   7개의 데이터 타입은 원시 타입과 객체 타입으로 분류할 수 있다.

![스크린샷 2023-01-22 오후 5.51.29.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/58859b0f-c79a-4bb7-a3e5-630b874fb5ee/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-22_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.51.29.png)

### 6.1 숫자 타입

-   ECMAScript에서는 모든 수를 실수로 처리한다. (number)
    -   세 가지 특별한 값도 표현할 수 있다.
    -   Infinity: 양의 무한대
    -   -Infinity: 음의 무한대
    -   NaN: 산술 연산 불가 (not-a-number)

```jsx
// 숫자 타입은 모두 실수로 처리된다.
console.log(1 === 1.0); // true
```

### 6.2 문자열 타입

-   문자열은 ‘’, “”, `` 으로 텍스트를 감싼다. 자바스크립트에서는 일반적으로 작은 따음표를 사용한다.

### 6.3 템플릿 리터럴

-   ES6부터 백틱(``)을 사용하는 템플릿 리터럴이라하는 새로운 문자열 표기법이 도입되었다.
    -   멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 제공

### 6.3.1 멀티라인 문자열

-   일반적인 문자열 내에서는 줄바꿈(개행)이 허용되지 않는다.

    -   따라서 일반 문자열에서는 이스케이프 시퀀스를 사용한다 (\a, \b, \n, \f..)

-   일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 모든 공백도 있는 그대로 적용된다.

### 6.3.2 표현식 삽입

-   문자열은 문자열 연산자 +를 사용해 연결할 수 있다.

    -   피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작하고, 그 외는 덧셈 연산자로 동작한다.

-   템플릿 리터럴 내에서는 표현식 삽입을 통해 간단히 문자열을 삽입할 수 있다.
    -   보다 가독성 좋고 간편하게 문자열 조합 가능

```jsx
var first = "chaeyeon";
var last = "yang";

// ES6: 표현식 삽입
console.log(`My name is ${first} ${last}.`);
console.log(`1+2=${1 + 2}`);
```

### 6.4 불리언 타입

-   논리적 참, 거짓을 나타내는 true와 false

### 6.5 undefined 타입

-   var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화된다.

    -   초기화되지 않은 변수

-   변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태(대부분 비어 있지 않고 쓰레기 값이 들어있다)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화된다.

-   변수에 값이 없다는 것을 명시하고 싶을 때는 undefined가 아니라 null을 할당한다.

### 6.6 null 타입

-   프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다.

-   함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다.

### 6.7 심벌 타입

-   심벌은 ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다.
    -   심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다.
    -   따라서 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.
    -   생성된 심벌 값은 외부에 노출되지 않는다.

```jsx
// 심벌 값 생성
var key = Symbol("key");
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = "value";
console.log(obj[key]); // value
```

### 6.8 객체 타입

-   자바스크립트는 객체 기반의 언어이며, **자바스크립트를 이루고 있는 거의 모든 것이 객체**이다.

### 6.9 데이터 타입의 필요성

### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

-   자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다.
    -   변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다.
    -   심벌 데이블: 컴파일러 또는 인터프리터는 심벌 테이블이라고 부르는 자료 구조를 통해 식별자를 키로 바인딩 된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.

### 6.9.2 데이터 타입에 의한 값의 해석

-   자바스크립트의 모든 값은 데이터 타입을 갖는다. 데이터 타입이 필요한 이유는 다음과 같다.
    -   값을 저장할 때 확보해야 하는 **메모리 공간의 크기를 결정**하기 위해
    -   값을 참조할 때 한 번에 읽어 들어야 할 **메모리 공간의 크기를 결정**하기 위해
    -   메모리에서 읽어 들인 **2진수를 어떻게 해석**할지 결정하기 위해

### 6.10 동적 타이핑

### 6.10.1 동적 타입 언어와 정적 타입 언어

-   C나 자바같은 **정적 타입 언어**는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류. 즉 데이터 타입을 사전에 선언해야 한다. (=명시적 타입 선언)
    -   정적 타입 언어는 컴파일 시점에 **타입 체크**(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리)를 수행한다.
    -   타입의 일관성을 강제함으로써 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄인다
    -   ex) C, C++, 자바, 코틀린, 고, 하스켈, 러스트, 스칼라..

```jsx
// c 변수에는 1바이트 정수 타입의 값(-128~127)만 할당할 수 있다.
char c;
```

-   자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다.

    -   미리 선언한 데이터 타입의 값만 할당할 수 있는 것이 아닌, 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다.

-   typeof 연산자로 변수를 연산하면 변수의 데이터 타입을 반환한다.

    -   정확히 말하면 변수의 데이터 타입을 반환하는 것이 아니라 변수에 할당된 값의 데이터 타입을 반환한다.

-   **자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.** 이러한 특징을 **동적 타이핑**이라 하며, 자바스크립트를 정적 타입 언어와 구별하기 위해 **동적 타입 언어**라 한다.
    -   ex) 자바스크립트, 파이썬, PHP, 루비, 리스프, 펄..

### 6.10.2 동적 타입 언어와 변수

-   모든 소프트웨어 아키텍처에는 트레이드오프가 존재하며, 모든 애플리케이션에 적합한 \*은 탄환은 없듯이 동적 타입 언어 또한 구조적인 단점이 있다.

    -   \*은 탄환: 고질적인 문제를 단번에 해결할 수 있는 명확한 해결책

-   변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다.

    -   값의 변경에 의해 타입도 언제든지 변경 될 수 있다
    -   따라서 동적 타입 언어의 변수는 값을 확인하기 전까지는 타입을 확신할 수 없다

-   자바스크립트는 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다.
    -   잘못된 예측에 의해 작성된 프로그램을 오류를 야기할 수 있다.

⇒ 동적 타입언어는 유연성은 높지만 신뢰성이 떨어진다.

[ 변수 사용시 주의할 점 ]

-   변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.
-   변수의 스코프는 최대한 좁게 만들어서 변수의 부작용을 억제해야한다.
-   전역 변수는 최대한 사용하지 않도록 한다.
-   변수보다는 상수를 사용해 값의 변경을 억제한다.
-   변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍 한다.

⇒ **가독성이 좋은 코드가 좋은 코드다.**
