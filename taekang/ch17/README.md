# Chapter.17 생성자 함수에 의한 객체 생성

---

> 객체 리터럴에 의한 객체 생성 방식은 가장 일반적이고 간단한 객체 생성 방식이다.
> **객체는 객체 리터럴 이외에도 다양한 방법으로 생성할 수 있다.**

## Object 생성자 함수

---

> new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 빈 객체를 생성한 이후 프로퍼티 또는 메서드를 추가하여 객체를 완성할 수 있다.

**`Object 생성자 함수를 사용해 객체를 생성하는 방식은 특별한 이유가 없으면 그다지 유용해 보이지 않는다.`**

---

## 생성자 함수

---

### 객체 리터럴에 의한 객체 생성방식의 문제점

---

> 객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하나 단 하나의 객체만 생성한다.
> **따라서 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적이다.**

**`프로퍼티는 객체마다 프로퍼티 값이 다를 수 있지만 메서드는 내용이 동일한 경우가 일반적이다`**

### 생성자 함수에 의한 객체 생성방식의 장점

---

> 생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.

```jsx
// 생성자 함수
function Circle(radius) {
  // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// 인스턴스의 생성
const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성
const circle2 = new Circle(10); // 반지름이 10인 Circle 객체를 생성

console.log(circle1.getDiameter()); // 10
console.log(circle2.getDiameter()); // 20
```

> 생성자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수다.
> 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 **new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.**

**`만약 new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다.`**

## 생성자 함수의 인스턴스 생성 과정

---

### 1. 인스턴스 생성과 this 바인딩

---

> 암묵적으로 빈 객체가 생성되고 이 빈 객체가 바로 생성자 함수가 생성한 인스턴스다.
> 그리고 인스턴스는 this에 바인딩된다.
> **생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유가 바로 이것이다.**

**`이 처리는 함수 몸체의 코드가 한 줄식 실행되는 런타임 이전에 실행된다.`**

### 2. 인스턴스 초기화

---

> 생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 this에 바인딩되어 있는 인스턴스를 초기화 한다.

**`이 처리는 개발자가 기술한다.`**

### 3. 인스턴스 반환

---

> 생성자 함수 내부에서 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this를 암묵적으로 반환한다.

**`만약 this가 아닌 다른 객체를 명시적으로 반환하면 return문에 명시한 객체가 반환된다.`**

**`하지만 명시적으로 원시 값을 반환하면 원시 값 반환은 무시되고 암묵적으로 this가 반환된다.`**

> 생성자 함수 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손한다. **따라서 생성자 함수 내부에서 return 문을 반드시 생략해야 한다.**

## 내부 메서드 [[Call]]과 [[Construct]]

---

> 함수는 객체이므로 일반 객체(ordinary object)와 동일하게 동작할 수 있다.
> 하지만 함수는 객체이지만 일반 객체와는 다르다.
> **일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.**

> 함수 객체는 함수 객체만을 위한 [[Environment]], [[FormalParameters]] 등의 내부 슬롯과 [[Call]], [[Construct]]같은 내부 메서드를 추가로 가지고 있다.

**`함수가 일반 함수로서 호출되면 내부 메서드 [[Call]]이 호출되고 new 연산자와 함께 생성자 함수로 호출되면 내부 메서드 [[Construct]]가 호출된다.`**

> 내부 메서드 [[Call]을 갖는 함수 객체를 호출할 수 있는 객체 **callable**이라 하며, 내부 메서드 [[Construct]]를 갖는 함수 객체를 생성자 함수로서 호출할 수 있는 함수 **constructor**, [[Construct]]를 갖지 않는 함수 객체를 생성자 함수로서 호출할 수 없는 함수 **non-constructor**라고 부른다.

**`함수 객체는 반드시 callable이여야 한다.`**

## constructor와 non-constructor의 구분

---

- constructor: 함수 선언문, 함수 표현식, 클래스(**클래스도 함수다**)
- non-constructor: 메서드(ES6 메서드 축약 표현), 화살표 함수

## new 연산자

---

> **new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다.**
> 함수 객체의 내부 메서드 [[Construct]]가 호출된다.

**`단, new 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor이어야 한다.`**

## new.target

---

> 생성자 함수가 new 연산자 없이 호출되는 위험성을 회피하기 위해 ES6에서는 new.target을 지원한다.
> 함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로서 호출되었는지 확인할 수 있다.

**`new 연산자와 함게 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다.`**

**`new 연산자 없이 일반 함수로 호출된 함수 내부의 new.target은 undefined다.`**
