# Chapter.12 함수

# Chapter.12 함수

---

> **함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.**

**`함수는 객체지만 일반 객체와는 다르다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.`**

## 함수 정의

- 함수 선언문

```jsx
function add(x, y) {
  return x + y;
}
```

- 함수 표현식

```jsx
let add = function (x, y) {
  return x + y;
};
```

- Function 생성자 함수

```jsx
let add = new Function("x", "y", "return x+y");
```

- 화살표 함수(ES6)

```jsx
let add = (x, y) => x + y;
```

## 함수 선언문

> 함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 리터럴은 함수 이름을 생략할 수 있으나 **함수 선언문은 함수 이름을 생략할 수 없다.**

**`함수 선언문은 표현식이 아닌 문이다.`**

**💡 자바스크립트 엔진은 함수 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석하고, 함수 리터럴이 값으로 평가되어야하는 문맥에서는 함수 리터럴 표현식으로 해석한다.**

**`자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.`**

## 함수 표현식

> 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 **함수 표현식**(function expression) 이라한다.

**💡 함수 선언문은 “표현식이 아닌 문”이고 함수 표현식은 “표현식인 문”이다.**

## 함수 생성 시점과 함수 호이스팅

> **함수 선언문으로 정의한 함수**는 **함수 선언문 이전에 호출할 수 있다.**
> 그러나 **함수 표현식으로 정의한 함수**는 **함수 표현식 이전에 호출할 수 없다.**

**💡 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성되고 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다.**

> 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **함수 호이스팅**(function hoisting)이라 한다.

> 변수 선언은 런타임 이전에 실행되어 undefined로 초기화되지만 **변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.**

**`함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.`**

## Function 생성자 함수

> Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지도 않다.

**`함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.`**

## 화살표 함수 (ES6)

> ES6에서 도입된 **화살표 함수**(arrow function)는 function 키워드 대신 화살표(fat arrow) ⇒를 사용해 **좀 더 간략한 방법으로 함수를 선언할 수 있다.**
> 화살표 함수는 **항상 익명함수로 정의한다.**

**`기존 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다.`**

## 인수 확인

> 함수를 저의할 때 적절한 인수가 전달되었는지 확인할 필요가 있다.

```jsx
function add(x, y) {
  if (typeof x !== "number" || typeof y !== "number") {
    // 매개변수를 통해 전달된 인수의 타입이 부적절한 경우 에러를 발생시킨다.
    throw new TypeError("인수는 모두 숫자 값이어야 합니다.");
  }

  return x + y;
}

console.log(add(2)); // TypeError: 인수는 모두 숫자 값이어야 합니다.
console.log(add("a", "b")); // TypeError: 인수는 모두 숫자 값이어야 합니다.
```

> 이처럼 함수 내부에서 적절한 인수가 전달되었는지 확인하더라도 부적절한 호출을 사전에 방지할 수는 없고 에러는 런타임에 발생하게 된다.

**`따라서 타입스크립트와 같은 정적 타입을 선언할 수 있는 자바스크립트의 상위 확장을 도입해서 컴파일 시점에 부적절한 호출을 방지할 수 있게 하는 것도 하나의 방법이다.`**

## 매개변수의 최대 개수

> **이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.**

**`따라서 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다.`**

**`만약 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다.`**

## 반환문

> **함수 호출은 표현식**이며 return 키워드가 반환한 표현식의 평가 결과, 즉 반환값으로 평가된다.

> 반환문은 두가지 역할을 한다.

- 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 따라서 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.
- 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환한다. return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.

**`반환문은 생략할 수 있다. 이때 함수는 함수 몸체의 마지막 문까지 실행한 후 암묵적으로 undefined를 반환한다.`**

## 참조에 의한 전달과 외부 상태의 변경

> **원시 타입 인수는 값 자체가 복사되어 매개변수에 전달되기 때문에** 함수 몸체에서 그 값을 변경(재할당을 통한 교체)해도 **원본은 훼손되지 않는다.**

> 하지만 **객체타입 인수는 참조 값이 복사되어 매개변수에 전달되기 때문에** 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 **원본이 훼손된다.**

**`이러한 문제의 해결 방법 중 하나는 객체를 불변 객체로 만들어 사용하는 것이다.`**

## 다양한 함수의 형태

### 즉시 실행 함수

> 함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수(IIFE, Immediately Invoked Function Expression)라고 한다. 즉시 실행 함수는 단 한 번만 호출되며 다시 호출할 수 없다.

```jsx
// 익명 즉시 실행 함수
(function () {
  let a = 3;
  let b = 5;
  return a * b;
})();
```

**`즉시 실행 함수는 반드시 그룹 연산자 (…)로 감싸야 한다.`**

## 재귀 함수

> 함수가 자기 자신을 호출하는 것을 **재귀 호출**(recursive call)이라 한다. **재귀 함수**는(recursive function)는 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말한다.

**`재귀 함수는 반복되는 처리를 반복문 없이 구현할 수 있다는 장점이 있지만 무한 반복에 빠질 위험이 있고 이로 인해 스택 오버플로 에러를 발생시킬 수 있으므로 반복문을 사용하는 것보다 재귀 함수를 사용하는 편이 더 직관적으로 이해가 쉬울 때만 한정적으로 사용하는 것이 바람직하다.`**

## 중첩 함수

> 함수 내부에 정의된 함수를 **중첩 함수**(nested function) 또는 **내부 함수**(inner function)라 한다. 그리고 중첩 함수를 포함하는 함수는 **외부 함수**(outer function)라 부른다.

**`중첩 함수는 함수 내부에서만 호출할 수 있다.`**

**`일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수(helper function) 역할을 한다.`**

## 콜백 함수

> 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 **콜백 함수**(callback function)라고 하며, 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 **고차 함수**(Higher-Order Function, HOF)라고 한다.

**`고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.`**

**`콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.`**

## 순수 함수와 비순수 함수

> 함수형 프로그래밍에서는 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 **순수 함수**(pure function)라 하고,
> 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수를 비순수 함수(impure function)라고 한다.
